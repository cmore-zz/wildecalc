<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Wilde Quantitative Jungian Calculator (Modern Minimal)</title>
<style>
  body {
    font-family: system-ui, sans-serif;
//    background: #faf7e6;

//    background: #f5f4f2;
    background: #f4f3ef;


    padding: 20px;
    line-height: 1.4;
  }

  h1 {
    color: #4d3e91;
    margin-bottom: 0.5em;
 }


a {
  color: #3d59c8;
}
a:hover {
  color: #2e47a3;
}
  .sliders {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    margin-left: 4px;   /* pulls it right to align visually */
  }

  @media(max-width: 800px) {
    .sliders {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  .card {
    border: 1px solid #999;
    border-radius: 4px;
    padding: 10px;
    background: white;
  }

  .labelrow { display: flex; justify-content: space-between; font-weight: bold; }
  .nums { font-size: 0.9em; margin-top: 4px; }

  .results { margin-top: 20px; }

  /* bar chart sizing */
  svg { width: 100%; }
  .bartext { font-size: 13px; fill: #333; text-anchor: middle; }




.graph-row {
  display: grid;
  grid-template-columns: 1fr auto;  /* bars grow, coupled chart stays compact */
  gap: 2rem;
  align-items: start;
}



@media (max-width: 800px) {
 .graph-row {
    grid-template-columns: 1fr; /* stack vertically */
  }
}


/* Keep the coupled-axis SVG pleasantly sized */

#coupledsvg {
  width: 100%;
  max-width: 220px;  /* scales up but not absurdly huge */
  aspect-ratio: 1 / 1;  /* square */
  height: auto;
}

.graphic-box {
  border: 1px solid #ccc;
  padding: 1rem;
  border-radius: 6px;
  background: #fff;
}



.graphic-box > legend {
  padding: 0 6px;
  font-weight: 600;
  color: #444;
}

.graphic-box {
  max-width: 800px;   /* pick your preferred limit */
  padding-left: 1rem;      /* aligns bar chart with your text content */
//  margin: 0 auto;     /* centers it nicely */
}

#barsvg {
  width: 100%;
  height: auto;
}

.num-edit {
  display: inline-block;
  min-width: 24px;
  padding: 2px 3px;
  border-radius: 4px;
}

.num-edit:focus {
  outline: 1px solid #bbb;
  background: #fff;
}


.results p + p {
  margin-top: 2px;     /* tiny breathing room between items */
}

.results {
  margin-top: 12px;    /* space above block */
}

.card {
  border: 1px solid #999;
  border-radius: 4px;
  padding: 10px 14px;
  background: white;
}

.results.card ul {
  padding-left: 18px;   /* gentle indent */
  margin: 8px 0;
}

.results.card li {
  margin: 4px 0;
  line-height: 1.28;
}

.results-box {
  margin-top: 1.75rem;   /* adjust to taste: 1.25–2rem all look good */
}



.results-box ul {
  margin: 6px 0 4px 0;
  padding-left: 20px;
}

.results-box li {
  margin: 3px 0;
  line-height: 1.28;
}

.results-box li::marker {
  color: #777;
}

.viewport-scroll-fade {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 40px;
  pointer-events: none;
  background: linear-gradient(
    to bottom,
    rgba(245, 241, 232, 0) 0%,
    rgba(245, 241, 232, 1) 90%
  );
}
</style>
</head>

<body>

<h1>Wilde Quantitative Jungian Calculator</h1>

  <b>How to use</b>: Adjust the sliders to match your MBTI preference strengths. Results section updates instantly.
  <p>
<details>
  <summary><strong>More Info</strong></summary>
  <p>This is a modernized minimal rewrite of the old Pyjamas-based calculator.</p>
</details>

<h2>MBTI Preferences</h2>

<div class="sliders">

  <!-- E–I -->
  <div class="card">
    <div class="labelrow"><span>E</span><span>I</span></div>
    <input type="range" min="0" max="100" value="50" id="ei">
    <div class="nums">
      <span id="e-val" class="num-edit" data-axis="ei" data-side="e" contenteditable="true">50</span> /
      <span id="i-val" class="num-edit" data-axis="ei" data-side="i" contenteditable="true">50</span>
    </div>
  </div>

  <!-- S–N -->
  <div class="card">
    <div class="labelrow"><span>S</span><span>N</span></div>
    <input type="range" min="0" max="100" value="50" id="sn">
    <div class="nums">
      <span id="s-val" class="num-edit" data-axis="sn" data-side="n" contenteditable="true">50</span> /
      <span id="n-val" class="num-edit" data-axis="sn" data-side="s" contenteditable="true">50</span>
    </div>
  </div>

  <!-- T–F -->
  <div class="card">
    <div class="labelrow"><span>T</span><span>F</span></div>
    <input type="range" min="0" max="100" value="50" id="tf">
    <div class="nums">
      <span id="t-val" class="num-edit" data-axis="tf" data-side="t" contenteditable="true">50</span> /
      <span id="f-val" class="num-edit" data-axis="tf" data-side="f" contenteditable="true">50</span>
    </div>
  </div>

  <!-- J–P -->
  <div class="card">
    <div class="labelrow"><span>J</span><span>P</span></div>
    <input type="range" min="0" max="100" value="50" id="jp">
    <div class="nums">
      <span id="j-val" class="num-edit" data-axis="jp" data-side="j" contenteditable="true">50</span> /
      <span id="p-val" class="num-edit" data-axis="jp" data-side="p" contenteditable="true">50</span>
    </div>
  </div>

</div>

<br>

<div class="graph-row">

  <fieldset class="graphic-box">
    <legend>Function Strengths</legend>
    <svg id="barsvg" viewBox="0 0 600 160"></svg>
  </fieldset>

  <fieldset class="graphic-box small">
    <legend>Coupled Attitude Space</legend>
    <svg id="coupledsvg"
      viewBox="0 0 200 200"
      style="background:#fdfdfd;border:1px solid #ccc; ">
      <defs>
        <pattern id="grid" width="25" height="25" patternUnits="userSpaceOnUse">
          <rect width="25" height="25" fill="none" stroke="#ddd" stroke-width="1" />
        </pattern>
      </defs>
      <rect x="0" y="0" width="200" height="200" fill="url(#grid)" />

      <text x="5" y="15" font-size="12" fill="#888">Ep: Exploration</text>
      <text x="130" y="15" font-size="12" fill="#888">Ej: Control</text>
      <text x="5" y="195" font-size="12" fill="#888">Ip: Appraisal</text>
      <text x="130" y="195" font-size="12" fill="#888">Ij: Focus</text>

      <circle id="dot" cx="100" cy="100" r="5" fill="red"></circle>
    </svg>

  </fieldset>

</div>



<fieldset class="graphic-box results-box">
  <legend>Results</legend>

  <ul>
    <li><strong>Preferred Modes:</strong> <span id="func-text">?</span></li>
    <li><strong>Code:</strong> <span id="type-code">????</span></li>
    <li><strong>Attitude Position:</strong> <span id="attitude-pos">?</span></li>
    <li><strong>Mode Signature:</strong> <span id="mode-signature">?</span></li>
    <li><strong>Link:</strong> <span id="link-url">?</span></li>
  </ul>

</fieldset>  

<div class="viewport-scroll-fade"></div>

<script>
/* ---------- Helpers ---------- */

function axisValues() {
  const e = (100 - Number(document.getElementById("ei").value)) / 100;
  const i = 1 - e;
  const s = (100 - Number(document.getElementById("sn").value)) / 100;
  const n = 1 - s;
  const t = (100 - Number(document.getElementById("tf").value)) / 100;
  const f = 1 - t;
  const j = (100 - Number(document.getElementById("jp").value)) / 100;
  const p = 1 - j;

  return { e, i, s, n, t, f, j, p };
}



function computeFunctions(av) {
  return {
    Se: (((av.e + av.p) / 2) + av.s) / 2,
    Ne: (((av.e + av.p) / 2) + av.n) / 2,
    Te: (((av.e + av.j) / 2) + av.t) / 2,
    Fe: (((av.e + av.j) / 2) + av.f) / 2,
    Si: (((av.i + av.j) / 2) + av.s) / 2,
    Ni: (((av.i + av.j) / 2) + av.n) / 2,
    Ti: (((av.i + av.p) / 2) + av.t) / 2,
    Fi: (((av.i + av.p) / 2) + av.f) / 2
  };
}


function updateBars(funcs) {
  const svg = document.getElementById("barsvg");
  const names = ["Se","Si","Ne","Ni","Te","Ti","Fe","Fi"];

  // pick spacing based on viewport width

  const spacing =
    window.innerWidth < 400 ? 44 :
    window.innerWidth < 600 ? 52 :
    window.innerWidth < 900 ? 62 :
    70;
  const totalWidth = spacing * names.length + 40;
  svg.setAttribute("viewBox", `0 0 ${totalWidth} 160`);

  svg.innerHTML = `      <line x1="0" y1="80" x2="${totalWidth}" y2="80"
         stroke="#d8d8d8" stroke-width="1" stroke-dasharray="2 8" /> `;

  names.forEach((name, idx) => {
    const val = funcs[name];
    const height = val * 120;
    const x = idx * spacing + 20;
    const y = 140 - height;

    const displayVal = Math.round((val * 200) - 100);
    const opacity =
        displayVal > 0  ? 1.0 :
        displayVal === 0 ? 0.65 :
                           0.40;

    svg.innerHTML += `



      <rect x="${x}" y="${y}" width="40" height="${height}"
            fill="hsl(${idx*40},70%,60%)"
            fill-opacity="${opacity}"
            stroke="#333"
            stroke-opacity="${opacity}"></rect>
      <text x="${x+20}" y="155" class="bartext" fill-opacity="${opacity}">${name}</text>
      <text x="${x+20}" y="${y-5}" fill-opacity="${opacity}" class="bartext">${Math.round((val*200)-100)}</text>

    `;
  });
}

function updateDot(av) {
  const dot = document.getElementById("dot");
  const x = av.j * 200;
  const y = 200 - av.e * 200;
  dot.setAttribute("cx", x);
  dot.setAttribute("cy", y);
}

function updateText(funcs) {
  const sorted = Object.entries(funcs).sort((a,b)=>b[1]-a[1]);
  const strong = sorted.filter(x => x[1] > 0.5).map(x => {
    const pct = Math.round((x[1]*200)-100);
    return `${x[0]} ${pct}%`;
  }).join(", ");
  document.getElementById("func-text").textContent = strong || "?";
}

function typeCode(av) {
  const pick = (v, a, b) => v === 0.5 ? "X" : (v > 0.5 ? a : b);
  return pick(av.e,"E","I") + pick(av.s,"S","N") +
         pick(av.t,"T","F") + pick(av.j,"J","P");
}

function computeModeSignature(funcs) {
  const clusters = {
    "Extraverted Perceiving (Se/Ne)": funcs.Se + funcs.Ne,
    "Introverted Perceiving (Si/Ni)": funcs.Si + funcs.Ni,
    "Extraverted Judging (Te/Fe)": funcs.Te + funcs.Fe,
    "Introverted Judging (Ti/Fi)": funcs.Ti + funcs.Fi
  };

  // Sort clusters by strength
  const entries = Object.entries(clusters).sort((a,b)=>b[1]-a[1]);
  
  const [topName, topVal] = entries[0];
  const [secondName, secondVal] = entries[1];

  // Strength percentage (0 = baseline, 100 = max)
  const pct = Math.round((topVal * 100));

  let summary = `${topName}`;

  // If second is strong, mention it
  if ((topVal - secondVal) < 0.08) {  // within 8%
    summary += ` with ${secondName.toLowerCase()} as secondary`;
  }

  return summary;
}

function render() {
  const av = axisValues();
  const funcs = computeFunctions(av);

  // update numbers
  document.getElementById("e-val").textContent = Math.round(av.e*100);
  document.getElementById("i-val").textContent = Math.round(av.i*100);
  document.getElementById("s-val").textContent = Math.round(av.s*100);
  document.getElementById("n-val").textContent = Math.round(av.n*100);
  document.getElementById("t-val").textContent = Math.round(av.t*100);
  document.getElementById("f-val").textContent = Math.round(av.f*100);
  document.getElementById("j-val").textContent = Math.round(av.j*100);
  document.getElementById("p-val").textContent = Math.round((1-av.j)*100);

  document.getElementById("attitude-pos").textContent = attitudeLabel(av);

  document.getElementById("mode-signature").textContent =
    computeModeSignature(funcs);

  updateBars(funcs);
  updateDot(av);
  updateText(funcs);
  updateLink();
  document.getElementById("type-code").textContent = typeCode(av);
}

document.querySelectorAll("input[type=range]").forEach(r => {
  r.addEventListener("input", render);
});


document.querySelectorAll('.num-edit').forEach(el => {
  el.addEventListener('blur', () => {
    let v = parseInt(el.textContent, 10);
    if (isNaN(v)) v = 50;
    v = Math.max(0, Math.min(100, v));

    const axis = el.dataset.axis;   // "ei", "sn", "tf", "jp"
    const side = el.dataset.side;   // "e" or "i", "s" or "n", etc.
    const slider = document.getElementById(axis);

    // Convert axis value into slider thumb value
    // Slider direction: left = first letter (0), right = second letter (100)
    //
    // Example: axis "tf":
    //   - T is the *left* pole (so slider.value = 100 - T)
    //   - F is the *right* pole (so slider.value = F)
    //

    // Determine which pole is left or right for this axis
    const leftPole  = axis[0];   // e, s, t, j
    const rightPole = axis[1];   // i, n, f, p

    let sliderValue;

    if (side === leftPole) {
      // If editing left pole, slider should move right when value is LOW
      sliderValue = 100 - v;
    } else {
      // Editing right pole directly maps to slider
      sliderValue = v;
    }

    // Clamp
    sliderValue = Math.max(0, Math.min(100, sliderValue));
    slider.value = sliderValue;

    // Now update the opposite side’s displayed text
    const otherSide = (side === leftPole) ? rightPole : leftPole;
    const otherEl = el.parentElement.querySelector(`.num-edit[data-side="${otherSide}"]`);

    const otherVal =
      (side === leftPole) ? (100 - v)
                          : (100 - v);

    otherEl.textContent = otherVal;

    // Finally refresh entire UI
    render();
  });
});

function updateLink() {
  const av = axisValues();   // uses your existing function
  const params = new URLSearchParams();

  // raw 0–100 values
  const i = Math.round(av.i * 100);
  const n = Math.round(av.n * 100);
  const f = Math.round(av.f * 100);
  const p = Math.round((1 - av.j) * 100);  // p = 1 - j

  params.set("i", i);
  params.set("n", n);
  params.set("f", f);
  params.set("p", p);

  // construct a link based on current page URL
  const base = window.location.href.split("?")[0];
  const url = `${base}?${params.toString()}`;

  document.getElementById("link-url").innerHTML =
    `<a href="${url}">${url}</a>`;
}

function loadFromURL() {
  const p = new URLSearchParams(window.location.search);

  const axes = ["i","n","f","p"];  // the four encoded params
  const mapping = { i:"ei", n:"sn", f:"tf", p:"jp" };

  axes.forEach(ax => {
    if (p.has(ax)) {
      const raw = Number(p.get(ax));  // 0–100
      const sliderId = mapping[ax];
      const slider = document.getElementById(sliderId);

      if (ax === "p") {
        // p = 100−j
        slider.value = raw;  // slider.value is P-side (right pole)
      } else {
        // left side uses inverted encoding
        slider.value = 100 - raw;
      }
    }
  });
}


function attitudeLabel(av) {
  const e = av.e;
  const j = av.j;

  // Balanced means too close to the midpoint to justify a quadrant label
  const BAL = 0.45;  // you can tighten or loosen this

  const eBalanced = (e > BAL && e < (1 - BAL));   // around 0.50
  const jBalanced = (j > BAL && j < (1 - BAL)); 

  let vert, horiz, quadrant = null;

  // Human-readable orientation text
  vert = (e > 0.65) ? "Extraverted"
      : (e < 0.35) ? "Introverted"
      : "Balanced E/I";

  horiz = (j > 0.65) ? "Judging-oriented"
        : (j < 0.35) ? "Perceiving-oriented"
        : "Balanced J/P";

  // Only assign Wilde quadrant if *both* axes are meaningfully polarized
  if (!eBalanced && !jBalanced) {
    if (e > 0.5 && j > 0.5) quadrant = "Ej (Control)";
    else if (e > 0.5 && j <= 0.5) quadrant = "Ep (Exploration)";
    else if (e <= 0.5 && j > 0.5) quadrant = "Ij (Focus)";
    else quadrant = "Ip (Appraisal)";
  }

  // If there is a quadrant, include it. Otherwise just descriptors.
  return quadrant
    ? `${vert}, ${horiz} — ${quadrant}`
    : `${vert}, ${horiz}`;
}

loadFromURL();
render(); // initial
</script>

</body>
</html>
